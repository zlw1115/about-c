**变量说明符**

C语言允许声明变量的时候，加上一些特定的说明符（specifier），为编译器提供变量行为的额外信息。他的主要作用是帮助编译器优化代码。

**const**

const说明符表示变量是制度的，不得被修改。

```
const double PI = 3.1415;
PI = 3; // 报错
```

对于数组，const表示数组成员不能修改。

```
const int arr[] = {1, 2, 3, 4};
arr[0] = 5; // 报错；const使得数组arr的成员无法修改。
```

对于指针变量，const有两种写法，含义不一样。如果const在*前面，表示指针指向的值不可修改。

```
// const表示指向的值*x不能修改
int const * x;
// 或者
const int* x;

// 对x指向的值进行修改导致报错
int p = 1;
const int* x = &p;
(*x)++; // 报错
```

如果const在*后面，表示指针包含的地址不可修改。

```
// const 表示地址x不能修改
int* const x;

// 对x进行修改导致报错
int p = 1;
int* const x = &p;
x++; // 报错
```

两者可以结合

```
const char* const x;
```

指针变量x指向一个字符串。两个const意味着，x包含的内存地址以及x指向的字符串，都不能修改。

const的一个用途，就是防止函数体内修改函数参数。如果某个参数在函数体内不会被修改，可以在函数声明时，对该参数添加const说明符。这样的话，在调用函数前后，参数数组保持不变。

```
void find(const int* arr, int n);
```

上面示例中，函数find的参数数组arr有const说明符，就说明该数组在函数内部将保持不变。

有一种情况需要注意，如果一个指针变量指向const变量，那么该指针变量也不应该被修改。

```
const int i = 1;
int* j = &i;
*j = 2; // 报错
```

j是一个指针变量，指向变量i，即j和i指向同一个地址。j本身没有const说明符，但是i有，这种情况下，j指向的值也不能被修改。

**static**

static说明符对于全局变量和局部变量有不同的含义。

1. 用于局部变量（位于块作用域内部）

   static用于函数内部声明的局部变量时，表示该变量的值会在函数每次执行后得到保留，下次执行时不会进行初始化，就类似于一个只用于函数内部的全局变量。由于不必每次执行函数时，都对该变量进行初始化，这样可以提高函数的执行速度。

2. 用于全局变量（位于块作用域）

   static用于汉纳树外部声明的全局变量时，表示该变量只用于当前文件，其他源码文件不可以引用改变量，即该变量不会被连接（link）。

   static修饰的变量，初始化时，值不能等于变量，必须是常量。

   ```
   int n = 10;
   static m = n;
   ```

   变量m有static修饰，他的值如果等于变量n，就会报错，必须等于常量。

   只在当前文件里面使用的函数，也可以声明为static，表明该函数只在当前文件使用，其他文件可以定义同名函数。

   ```
   static int g(int i);
   ```

**auto**

auto说明符表示该变量的存储，由编译器自主分配内存空间，且只存在于定义时所在的作用域，退出作用域时会自动释放。由于只要不是extern的变量（外部变量），都是由编译器自主分配内存空间的，这属于默认行为，所以该说明符没有实际作用，一般都省略不写。

```
auto int a;
// 等同于
int a;
```

**extern**

extern说明符表示，该变量在其他文件里面声明，没有必要在当前文件里面为他分配空间。通常用来表示，该变量是多个文件共享的。

```
extern int a;
```

a是extern变量，表示该变量在其他文件里面定义和初始化，当前文件不必为它分配存储空间。

但是，变量声明时，同时进行初始化，extern就会无效。

```
// extern 无效
extern int i = 0;

// 等同于
int i = 0;
```

上面代码中，extern对变量的初始化声明是无效的，这是为了防止多个extern对同一个变量进行多次初始化。函数内部使用extern声明变量，就相当于改变量是静态存储，每次执行时都要从外部获取它的值。函数本身默认是extern，即该函数可以被外部文件共享，通常省略extern不写。如果只希望函数在当前文件可用，那就需要在函数前面加上static。

```
extern int f(int i);
// 等同于
int f(int i);
```

**register**

register说明符向编译器表示，该变量是经常使用的，应该提供最快的读取速度，所以应该放进寄存器。但是，编译器可以忽略这个说明符，不一定按照这个指示行事。

```
register int a;
```

register只对声明在代码块内部的变量有效。设为register的变量，不能获取它的地址。

```
register int a;
int *p = &a; // 编译器报错
```

&a会报错，因为变量a可能放在寄存器里面，无法获取内存地址。

如果数组设为register，也不能获取整个数组或一个数组成员的地址。

```
register int a[] = {11, 22, 33, 44, 55};
int p = a; // 报错
int a = *(a+2); // 报错
```

历史上，CPU内部的缓存，称为寄存器（register）。与内存相比，寄存器的访问速度快得多，所以使用他们可以提高速度。但是他们不在内存之中，所以没有内存地址，这就是为什么不能获取指向它们的指针地址。现代编译器已经有巨大的进步了，会尽可能的优化代码，按照自己的规则决定怎么利用好寄存器，取得最佳的执行速度，所以可能会忽视代码里面的register说明符，不保证一定会把这些变量放到寄存器。

**volatile**

volatile说明符表示苏所声明的变量，可能会预想不到地发生变化（即其他程序可能会更改它的值），不受当前程序控制，因此编译器不要对这类变量进行优化，每次使用时都应该查询一下它的值。硬件设备的编程中，这个说明符很常用。

```
volatile int foo;
volatile int* bar;
```

volatile的目的是阻止编译器对变量行为进行优化，

```
int foo = x;
// 其他语句，假设没有改变x的值
int bar = x;
```

由于变量foo和bar都等于x，而且x的值也没有发生变化，所以编译器可能会把x放入缓存，直接从缓存读取值（而不是从x的原始位置读取），然后对foo和bar进行赋值。如果x被设定为volatile，编译器就不会把他放入缓存，每次都从原始位置去读取x的值，因为在两次读取之间，其他程序可能会改变x。

**restrict**

restrict说明符允许编译器优化某些代码。它只能用于指针，表明该指针是访问数据的唯一方式。

```
int* restrict pt = (int*) malloc(10 * sizeof(int));
```

restrict表示变量pt是访问malloc所分配内存的唯一方式。

```
int foo[10];
int* bar = foo;
```

变量foo指向的内存，可以用foo访问，也可以用bar访问，因此就不能将foo设为restrict。

如果编译器知道某一块内存只能用一个方式访问，可能可以更好地优化代码，因为不用担心其他地方会修改值。

restrict用于函数参数时，表示参数的内存地址之间没有重叠。

```
void swap(int* restrict a, int* restrict b){ // 参数a和参数b的内存地址没有重叠
  int t;
  t = *a;
  *a = *b;
  *b = t
}
```























































