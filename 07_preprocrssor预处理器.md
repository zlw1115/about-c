**预处理器Preprocessor**

C语言编译器在编译程序之前，会先使用预处理器（preprocessor）处理代码。

预处理器首先会清理代码，进行删除注释、多行语句合成一个逻辑行等工作。然后，执行#开头的预处理指令。预处理指令可以出现在程序的任何地方，从指令出现的地方到文件末尾都有效，但习惯上，往往放在代码的开头部分。

每个预处理指令都以#开头，放在一行的行首，指令前面可以有空白字符（比如空格或制表符）。#和指令的其余部分之间也可以有空格，但是为了兼容老的编译器，一般不留空格。所有预处理指令都是一行的，除非在行尾使用反斜杠，将其折行。指令结尾处不需要分号。

**#define**

#define是最常见的预处理器指令，用来将指定的词替换成另一个词。它的参数分成两个部分，第一个参数就是要被替换的部分，其余参数是替换后的内容。每条替换规则，称为一个宏（macro）。

同名的宏可以重复定义，只要定义是相同的，就没有问题。如果定义不同，就会报错。

```
// 正确
#define FOO hello
#define FOO hello

// 报错
#define BAR hello
#define BAR world
```

**带参数的宏**

```
#define SOUARE(X) X*X
```

宏SOUARE可以接受一个参数X，替换成X*X。注意，宏的名称与左边圆括号之间，不能有空格。

```
z = SOUARE(2); // 替换成z = 2*2
```

写法很像函数，但不是函数，而是完全原样替换，会更函数有不一样的行为。

```
SOURCE(3+4); // 3+4*3+4，最后输出19
// 如果是函数，输出的应该是7*7 49
```

原样替换可能导致意料之外的行为。解决方法就是在定义宏的时候，尽量都使用圆括号，这样可以避免意外

```
#define SOUARE(X) ((X) * (X))
```

一般来说，应该首先使用函数，它的功能更强、更容易理解。宏有时候产生意料不到的替换结果，而且往往只能写成一行，除非对换行符进行转义，但是可读性就变得很差。

宏的优点是相对简单，本质上是字符串替换，不涉及数据类型，不像函数必须定义数据类型。而且，宏将每一处都替换成实际的代码，省掉了函数调用的开销，所以性能会好一些。另外，以前的代码大量使用宏，尤其是简单的数学运算。

**#运算符， ##运算符**

由于宏不涉及数据类型，所以替换以后可能为各种类型的值。如果希望替换后的值为字符串，可以在替换文本的参数前面加上#。

```
#define STR(x) #x

a = STR(3.141596); // a为字符串"3.141596"
```

```
#define XNAME(n) "x"#n

a = XNAME(4); // a为字符串"x4"
```

如果替换后的文本里面，参数需要跟其他标识符连在一起，组成一个新的**标识符**，可以使用##运算符。它起到粘合作用，将参数“嵌入”一个标识符之中。

```
#define MK_ID(n) i##n

int MK_ID(1), MK_ID(2), MK_ID(3);
// 替换成
int i1, i2, i3; // 参数n是标识符的一部分
```

##运算符的一个主要用途就是批量生成变量名和标识符。

**不定参数的宏**

宏的参数还可以是不定数量的（即不确定有多少个参数），...表示剩余的参数。

```
#define X(a, b, ...) (10*(a) + 20*(b)), __VA_ARGS__
```

X(a, b, ...)表示X()至少有两个参数，多余的参数使用...表示。在替换文本中，\__VA_ARGS__代表多余的参数（每个参数之间使用逗号分隔）。

```
X(5, 4, 3.14, "Hi!", 12)
// 替换成
(10*(5) + 20*(4)), 3.14, "Hi!", 12
```

注意，...只能替代宏的尾部参数，不能写成下面这样。

```
// 报错
#define WRONG(x, ..., Y) #X #__VA_ARGS__ #Y 
// ...替代中间部分的参数，这是不允许的，会报错
// __VA_ARGS__前面加上一个#号，可以让输出变成一个字符串
```

**#undef**

#undef指令用来取消已经使用#define定义的宏

```
#define LIMIT 400
#undef LIMIT // undef指令取消已经定义的宏LIMIT，后面就可以重新用LIMIT定义一个宏
```

有时候想重新定义一个宏，但不确定是否以前定义过，就可以先用#undef取消，然后再定义。因为同名的宏如果两次定义不一样，会报错，而#undef的参数如果是不存在的宏，并不会报错。

GCC的-U选项可以在命令行取消宏的定义，相当于#undef

```
$ gcc -ULIMIT foo.c
// -U参数取消了宏LIMIT，相当于源文件里面的#undef LIMIT
```

**#include**

#include指令用于编译时将其他源码文件，加载进入当前文件。

```
// 形式一
#include <foo.h> // 加载系统提供的文件

// 形式二
#include "foo.h" // 加载用户提供的文件
```

形式一，文件名写在尖括号里面，表示该文件是系统提供的，通常是标准库的库文件，不需要写路径。因为编译器会到系统指定的安装目录里面，去寻找这些文件。

形式二，文件名写在双引号里面，表示该文件由用户提供，具体的路径取决于编译器的设置，可能是当前目录，也可能是项目的工作目录。如果所要包含的文件在其他位置，就需要指定路径。

```
#include "/usr/local/lib/foo.h"
```

GCC编译器的-I参数，也可以用来指定include命令中用户文件的加载路径。

```
$ gcc -Iinclude/ -o code code.c
```

-Iinclude指定从当前目录的include子目录里面，加载用户自己的文件。

#include最常见的用途，就是用来加载包含函数原型的头文件（后缀名为.h）。多个#include指令的顺序无关紧要，多次包含同一个头文件也是合法的。

**#if...#endif**

#if...#endif指令用于预处理器的条件判断，满足条件时，内部的行会被编译，否则就被编译器忽略。

```
#if 0
  const double pi = 3.1415; // 不会执行
#endif
```

#if后面的0，表示判断条件不成立。所以，内部的变量定义语句会被编译器忽略。#if 0这种写法常用来当作注释使用，不需要的代码放在#if 0里面。

#if后面的判断条件，通常是一个表达式。如果表达式的值不等于0，就表示判断条件为真，编译内部的语句；如果表达式判断条件为伪，则忽略内部的语句。

#if...#endif之间还可以加入#else指令，用于指定判断条件不成立时，需要编译的语句。如果有多个判断条件，还可以加入#elif指令。

```
#if
  //
#elif
  //
#else
  //
#endif
```

没有定义过的宏，等同于0。因此如果UNDEFINED是一个没有定义过的宏，那么#if UNDEFINED为伪，而#if !UNDEFINED为真。

#if的常见应用就是打开（或关闭）调试模式

```
#define DEBUG 1
#if DEBUG
  //
#endif
```

GCC的-D参数可以在编译时指定宏的值，因此可以很方便地打开调试开关。

```
$gcc -DDEBUG=1 foo.c
```

**#ifdef...#endif**

#ifedf...#endif指令用于判断某个宏是否定义过。

有时源码文件可能会重复加载某个库，为了避免这种情况，可以在库文件里使用#define定义一个空的宏。通过这个宏，判断库文件是否被加载了。

```
#ifdef MAVIS
  #include "foo.h"
  #define STABLES 1
 #else
   #include "bar.h"
   #define STABLES 2
 #endif
```

通过判断宏MAVIS是否定义过，实现加载不同的头文件。

**defined运算符**

#ifdef指令等同于#if defined

```
#ifdef FOO
// 等同于
#if defined FOO
```

defined是一个预处理运算符，如果它的参数是一个定义过的宏，就会返回1，否则返回0。

```
#if defined IBMPC
  #include "ibmpc.h"
#elif defind MAC
  #include "mac.h"
#else
  #include "general.h"
#endif
```

对不同的架构系统需要定义对应的宏。代码根据不同的宏，加载对应头文件。

**#ifndef...#endif**

#ifnedf...#endif指令跟#ifdef...#endif正好相反，用来判断，如果某个宏没有定义过，则执行指定的操作。、

```
#ifdef EXTRA_HAPPY
  //
#endif

#ifnedf EXTRA_HAPPY
  //
#endif
```

上例中，根据宏EXTRA_HAPPY是否被定义过，#ifdef和#ifnedf分别指定了两种情况，各自需要编译的代码。

#ifndef常用于防止重复加载。

**预定义宏**

C语言提供一些预定义的宏，可以直接使用。

- \__DATE__: 编译日期，格式为"Mmm dd yyyy"的字符串（比如 Nov 23 2021）
- \__TIME__: 编译时间，格式为"hh:mm:ss"
- \__FILE__: 当前文件名
- \__LINE__: 当前行号
- \__func__: 当前正在执行的函数名。该预定义宏必须在函数作用域使用
- \__STDC__: 如果被设为1，表示当前编译器准许C标准
- \__STDC_HOSTED__: 如果被设为1，表示当前编译器可以提供完整的标准库；否则被设为0（嵌入式系统的标准库常常是不完整的）
- \__STDC_VERSION__: 编译所使用的C语言版本，是一个格式为yyymml的长整数，C99版本为“199901L”，C11版本为“201112L”，C17版本为“201710L”

**#line**

#line指令用于覆盖预定义宏\__LINE__，将其改为自定义的行号。后面的行号将从\__LINE__的新值开始计数。

```
#line 300
```

#line还可以改掉预定义宏\__FILE__，将其改为自定义的文件名

```
#line 300 "newfilename"
```

下一行的行号重置为300，文件名重置为newfilename

**#error**

#error指令用于让预处理器抛出一个错误，终止编译

```
#if __STDC_VERSION__ != 201112L
  #error
#endif
```

如果编译器不使用C11标准，就终止编译。

```
$ gcc -std=c99 newish.c
newish.c:14:2: error:#error Not C11
```

**#pragma**

#pragma指令用来修改编译器属性

```
// 使用C99标准
#pragma c9x on
```

让编译器以C99标准进行编译。

























