**C语言的内存管理**

c语言的内存管理，分成两部分。一部分是系统管理的，一部分是用户手动管理的。系统管理的内存，主要是函数内部的变量（局部变量）。这部分变量在函数运行时进入内存，函数运行结束后自动从内存卸载。这些变量存放的区域称为“栈”（stack），“栈”所在的内存是系统自动管理的。用户手动管理的内存，主要是程序运行的整个过程中都存在的变量（全局变量），这些变量需要用户手动从内存释放。如果使用后忘记释放，他就一直占用内存，知道程序退出。这种情况称为“内存泄漏”（memory leak）。这些变量所在的内存称为“堆”（heap），“堆”所在的内存是用户手动管理的。

每一块内存都有地址，通过指针变量可以获取指定地址的内存块。指针变量必须有类型，否则编译器无法知道如何解读内存块保存的二进制数据。

但是，想系统请求内存的时候，又是不确定会有什么样的数据写入内存，需要先获得内存块，稍后再确定写入的数据类型。为了满足这种需求，C语言提供了一种不定类型的指针，叫做void指针。它只有内存块的地址信息，没有类型信息，等到使用该块内存的时候，再向编译器补充说明，里面的数据类型是什么。另一方面，void指针等同于无类型指针，可以指向任意类型的数据，但是不能解读数据。void指针与其他所有类型指针之间是相互转换关系，任一类型的指针都可以转为void指针，而void指针也可以转为任一类型的指针。

注意：由于不知道void指针指向什么类型的值，所以不能用*运算符取出它指向的值。

**malloc()**

malloc()函数用于分配内存，该函数向系统要求一段内存，系统就在“堆”里面分配一段连续的内存块给它。它的原型定义在头文件stdlib.h。

```
void* malloc(size_t size)
```

它接受一个非负整数作为参数，表示所要分配的内存字节数，返回一个void指针，指向分配好的内存块。使用malloc()为任意类型的数据分配内存，常见的做法是先使用sizeof()函数，算出某种数据类型所需的字节长度，然后再将这个长度传给malloc()。

```
int *p = malloc(sizeof(int));
*p = 12;
printf("%d\n",*p); // 2
```

上面示例中，先为整数类型分配一段内存，然后将整数12放入这段内存里面。这个例子其实不需要使用malloc()，因为C语言会自动为整数提供内存。为了增加代码的可读性，可以对malloc()返回的指针进行一次强制类型转换。

```
int* p = (int*)malloc(sizeof(int));
```

sizeof()参数可以是变量，所以上面的例子也可以写成下面这样：

```
int *p = (int*)malloc(sizeof(*p))
```

malloc()分配内存有可能分配失败，这是返回常量NULL。NULL的值为0，是一个无法读写的内存地址，可以理解成一个不指向任何地方的指针。最好在使用malloc()之后检查是否分配成功。

```
int* p = malloc(sizeof(int));
if(p == NULL){
  // 内存分配失败
}

// or
if(!p){
  //...
}
```

malloc()最常用的场合，就是为数组和自定义的数据结构分配内存。p是一个整数指针，指向一段可以放置10个整数的内存，所以可以用作数组。

```
int* p = (int*)malloc(sizeof(int)*10);
```

malloc()可以用来创建动态数组，即根据成员数量的不同，而创建长度不同的数组。根据变量n的不同，动态为数组分配不同的大小。

```
int* p = (int*)malloc(n * sizeof(int));
```

注意：malloc()不会对所分配的内存进行初始化，里面还保存着原来的值。如果没有初始化，就是用这段内存，可能从里面读到以前的值。字符串初始化可以使用strcpy()函数。

```
char* p = malloc(4);
strcpy(p, "abc")
// 字符指针p指向一段4个字节的内存，strcpy()将字符串“abc”拷贝到这段内存，完成了这段内存的初始化。
```

**free()**

free()用于释放malloc()函数分配的内存，将这块内存还给系统以便重新使用，否则这个内存会一直占用到程序运行结束。

```
int* p = (int*)malloc(sizeof(int));
*p = 12;
free(p);
```

注意：分配的内存块一旦释放，就不应该再次操作已经被释放的地址，也不应该再次使用free()对该地址释放第二次。

**calloc()**

calloc()函数的作用与malloc()相似，也是分配内存块。

两者的区别主要有两点：

（1）calloc()接收两个参数，第一个参数是某种数据类型的值的数量，第二个是改数据类型的单位字节长度。

```
void* calloc(size_t n, size_t size);
```

calloc()的返回值也是一个void指针，分配失败时，返回NULL。

（2）calloc()会将所分配的内存全部初始化为0。malloc()不会对内存进行初始化，如果想要初始化为0，还要额外调用memset()函数。

```
int* p = calloc(10, sizeof(int));
//等同于
int* p = malloc(sizeof(int) * 10);
memset(p, 0, sizeof(int)*10);
```

calloc()分配的内存块，也要使用free()释放。

**realloc()**

realloc()函数用于修改已经分配的内存块的大小，可以放大也可以缩小，返回一个指向新的内存块的指针。如果分配不成功，返回NULL。

```
void* realloc(void* block, size_t size)
```

- block：已经分配好的内存块指针（由malloc()或calloc()或realloc()产生）。
- size：该内存快的新大小，单位为字节。

realloc()可能返回一个全新的地址（数据也会自动复制过去），也可能返回跟原来一样的地址。realloc()优先在原有内存块上进行缩减，尽量不移动数据，所以通常是返回原先的地址。如果新内存块小于原来的大小，则丢弃超出的部分；如果大于原来的大小，则不对新增的部分进行初始化（可以自动调用memset()）。

b是数组指针，realloc()动态调整他的大小。指针b原来指向10个成员的整数数组，使用realloc()调整为2000个成员的数组。这就是手动分配数组内存的好处，可以在运行时随时调整数组的长度。

```
int* b;
b = malloc(sizeof(int)*10)
b = realloc(b, sizeof(int)*2000)
```

如果realloc()的第二个参数是0，就会释放掉内存块。

由于有分配失败的可能，所以调用realloc()以后，最好检查一下它的返回值是否为NULL。分配失败时，原有内存中的数据不会发生改变。

```
float* new_p = realloc(p, sizeof(*p*40));
if(new_p==NULL){
  printf("Error reallocing\n");
  return 1;
}
```

注意：realloc()不会对内存块进行初始化。

**restrict说明符**

声明指针变量时，可以使用restrict说明符，告诉编译器，该块内存区域只有当前指针一种访问方式，其他指针不能读写该块内存。这种指针称为“受限指针”（restruct pointer）。

```
int* restrict p;
p = malloc(sizeof(int));

int* q = p;
*q = 0;
```

声明指针变量p时，加入了restrict说明符，使得p变成了受限指针。后面，当p指向malloc()函数返回的一块内存区域，就意味着，该区域只有通过p来访问，不存在其他访问方式。另一个指针q与受限指针p指向同一块内存，现在该内存有p和q两种访问方式。就违反了对编译器的承诺，后面通过*q对该内存区域赋值，会导致未定义行为。

**memcpy()**

memcpy()用于将一块内存拷贝到另一块内存。

```
void* memcpy(
  void* restrict dest,
  void* restrict source,
  size_t n
);
```

dest是目标地址，source是源地址，第三个参数n是要拷贝的字节数n。如果要拷贝10个double类型的数组成员，n就等于10*sizeof(double)，而不是10。该函数会将从source开始的n个字节，拷贝到dest。

dest和source都是void指针，表示这里不限制指针类型，各种类型的内存数据都可以拷贝。两者都有restrict关键字，表示这两个内存块不应该有互相重叠的区域。

memcpy()的返回值是第一个参数，即目标地址的指针。因为memcpy()只是将一段内存的值复制到另一段内存，所以不需要知道内存里面的数据是什么类型。

```
#include <stdio.h>
#include <string.h>

int main(void){
  char s[] = "Goats!";
  char t[100];
  
  memcpy(t,s,sizeof(s)); //拷贝7个字节，包括终止符
  printf("%s\n", t); // "Goats!"
  return 0;
}
```

memcpy()可以取代strcpy()进行字符串拷贝，而且是更好的方法，不仅安全，速度也更快，它不检查字符串尾部的\0字符。

```
char* s = "hello world";

size_t len = strlen(s) + 1;
char* c = malloc(len);

if(c){
  // strcpy()的写法
  strcpy(c, s;
  
  // memcpy()的写法
  memcpy(c, s, len);
}
// 两种写法的效果完全一样，但是memcpy()的写法要好与strcpy()
```

**memmove()**

memmove()函数用于将一段内存数据复制到另一段内存，他跟memcpy()的主要区别是，它允许目标区域与源区域有重叠。如果发生重叠，源区域的内存会被更改；如果没有重叠，它与memcpy()行为相同。

```
void* memmove(
  void* dest,
  void* source,
  size_t n
);
```

dest是目标地址，source是源地址，n是要移动的字节数。dest和source都是void指针，表示可以移动任何类型的内存数据，两个内存区域是可以有重叠。

```
// 数组成员a[1]开始的99个成员，都向前移动一个位置。
int a[100];
//...
memmove(&a[0], &a[1], 99 * sizeof(int));
```

```
char x[] = "Home Sweet Home"

// 输出Sweet Home Home
printf("%s\n", (char*)memmove(x, &x[5], 10))
```





**memcmp()**

memcmp()函数用来比较两个内存区域

```
int memcmp(
  const void* s1;
  const void* s2;
  size_t n
)
```

它接受三个参数，前面两个参数是用来比较的指针，第三个参数指定比较的字节数。

它的返回值是一个整数。两块内存区域的每个字节以字符形式解读，按照字典顺序进行比较，如果两者相同，返回0；如果s1大于s2，返回大于0的整数；如果s1小于s2，返回小于0的整数。















