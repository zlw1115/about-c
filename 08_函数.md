**函数**

函数是一段可以重复执行的代码。

```
int plus_one(int n){
  return n+1;
}
```

函数声明的语法：

1. 返回值类型。函数声明时，首先需要给出返回值的类型，上例是int，表示函数plus_one()返回一个整数。
2. 参数。函数名后面的圆括号里面，需要声明参数的类型和参数名，plus_one(int n)表示这个函数有一个整数参数n。
3. 函数体。函数体要写在大括号里面，后面（即大括号外面）不需要加分号。大括号的起始位置，可以跟函数名在同一行，也可以另起一行，本书采用同一行写法。
4. return语句。return语句给出函数的返回值，程序运行到这一行，就会跳出函数体，结束函数的调用。如果函数没有返回值，可以省略return语句，或者写成return;。

函数必须声明后使用，否则会报错。

C语言标准规定，函数只能声明在源码文件顶层，不能声明在其他函数内部。

不返回值的函数，使用void关键字表示返回值的类型。没有参数的函数，声明时要用void关键字表示参数类型。

```
void MyFunc(void){
  // ...
}
```

**main()**

C语言规定，main()是程序的入口函数，即所有的程序一定要包含一个mian()函数。程序总是从这个函数开始执行，如果没有该函数，程序就没法启动。其他函数同时通过它引入程序的。C语言约定，返回值0表示函数运行成功，如果返回其他非零整数，就表示运行失败，代码出了问题。系统根据main()的返回值，作为整个程序的返回值，确定程序是否运行成功。

正常情况下，如果main()里面省略return 0这一行，编译器会自动加上，即main()的默认返回值为0。由于C语言只会对main()函数默认添加返回值，对其他函数不会这样做。建议总是保留return语句。

**参数的传值引用**

如果函数的参数是一个变量，那么调用时，传入的是这个变量的值的拷贝，而不是变量本身。

如果想要传入变量本身，需要传入变量的地址。

注意：函数不要返回内部变量的指针，函数返回内部变量的指针，写法是错误的，因为当函数运行结束时，内部变量就消失了，这时指向内部变量i的内存地址就是无效的，再去使用这个地址是非常危险的。

**函数原型**

函数必须先声明，后使用。由于程序总是先运行main()函数，导致所有其他函数都必须在main()函数之前声明。

但是，main()是整个程序的入口，主要是逻辑，放在最前面比较好。另一方面，对于函数较多的程序，保证每个函数的顺序正确，会变得很麻烦。C语言提供的解决方法是，只要在程序开头处给出函数原型，函数就可以先使用、后声明。所谓函数原型，就是提前告诉编译器，每个函数的返回类型和参数类型。

```
// int twice(int num); // 编译器不会去解析参数名，但是有助于理解函数的意图
// 等同于
int twice(int); // 函数原型

int main(int num){
  return twice(num); // 使用
}

// 声明
int twice(int num){
  return 2 * num;
}
```

注意：函数原型必须以分号结尾。一般来说，每个源文件头部，都会给出当前脚本使用的所有函数的原型。

**exit()**

exit()函数用来终止整个程序的运行。一旦执行到该函数，程序就会立即结束。

exit()可以向程序外部返回一个值，它的参数就是程序的返回值。一般来说，使用两个常量作为它的参数：EXIT_SUCCESS（相当于0）表示程序运行成功，EXIT_FAILURE（相当于1）表示程序异常终止。

在main()函数里面，exit()等价于使用return语句。其他函数使用exit()，就是终止整个程序的运行，没有其他作用。

C蕴含还提供了一个atexit()函数，用来登记exit()执行时额外执行的函数，用来做一些退出程序时的收尾工作。

```
int atexit(void (*func)(void));
```

atexit()的参数是一个函数指针。注意，他的参数函数不能接受参数，也不能有返回值。

**函数说明符**

extern说明符

对于多文件的项目，源码文件会用到其他文件声明的函数。这是，当前文件里面，需要给出外部函数的原型，并用extern说明该函数的定义来自其他文件。

```
extern int foo(int arg1, char arg2);

int main(void){
  int a = foo(2,3)
  // ... 
  return 0
}
```

不过，由于函数原型默认就是extern，所以这里不加extern，效果是一样的。

**static说明符**

默认情况下，每次调用函数时，函数的内部变量都会重新初始化，不会保留上一次运行的值。static说明符可以改变这种行为。static用于函数内部声明变量时，表示改变量只需要初始化一次，不需要在每次调用时都进行初始化。也就是说，它的值在两次调用之间保持不变。

```
#include <stdio.h>

void counter(void){
  static int count = 1;
  printf("%d\n", count);
  count++;
}

int main(void){
  counter(); // 1
  counter(); // 2
  counter(); // 3
  counter(); // 4
}
```

注意，static修饰的变量初始化时，只能赋值为常量，不能赋值为变量。

static可以用来修饰函数本身，static关键字表示该函数只能在当前文件里使用，如果没有这个关键字，其他文件可以使用这个函数（通过声明函数原型）。

```
static int Twice(int num){
  return num*2;
}
```

static也可以用在参数里面，修饰参数数组。下例中，static对程序行为不会有任何影响，只是用来告诉编译器，该数组长度至少为3，某些请款下可以加快程序运行速度。另外，需要注意的是，对于多维数组的参数，static仅可用于第一维的说明。

```
int sum_array(int a[static 3], int n){
  // ...
}
```

**const说明符**

函数参数里面的const说明符，表示函数内部不得修改该参数变量。

```
void f(int* p){
  // ...
}
```

函数f()的参数是一个指针p，函数内部可能会改掉它所指向的值*p，从而影响到函数外部。

为了避免这种情况，可以在声明函数时，在指针参数前面加上const说明符，告诉编译器，函数内部不能修改该参数所指向的值。

```
void f(const int* p){
  *p = 0; // 改行报错
}
```

上面这种写法，只限制修改p所指向的值，而p本身的地址是可以修改的。

```
void f(const int* p){ // p本身可以修改，const只限定*p不能修改
  int x = 13;
  p = &x; // 允许修改
}
```

```
void f(int* const p){ // 限制修改p，可以把const放在p前面
  int x = 13;
  p = &x; // 改行报错
}
```

```
void f(const int* const p){
  // ...
}
```

**可变参数**

有些函数的参数数量是不确定的，声明函数的时候，可以使用省略号...表示可变数量的参数。

```
int printf(const char* format...)
```

上例是printf()函数的原型，除了第一个参数，其他参数的数量是可变的，与格式字符串里面的占位符数量有关。这是，就可以用...表示可变数量的参数。

注意，...符号必须放在参数序列的结尾，否则会报错。



















