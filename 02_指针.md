**指针**

指针是一个值，这个值代表一个内存地址，因此指针相当于指向某个内存的路标。

```
// 声明
int* intPtr; // 声明一个指针变量
int * foo, *bar; // 声明两个指针变量
```

```
// foo是一个指针，指向的还是一个指针，第二个指针指向的则是一个整数
int** foo; // 一个指针指向的还是指针，需要使用两个星号**
```

***运算符**

*这个符号除了表示指针以外，还可以作为运算符，用来**取出指针所指向的内存地址里面的值**。

```
void increment(int *p){
  *p = *p + 1;
}
/*
	该函数没有返回值，因为传入的是地址，函数体内部对该地址包含的值的操作，会影响到函数外部，所以不需要返回值。事实上，函数内部通过指针，将值传到外部，是C语言常用方法。
	变量地址而不是变量值传入函数，还有一个好处。对于需要大量存储空间的大型变量，复制变量值传入函数，非常浪费时间和空间，不如传入指针高效。
*/
```

函数increment()的参数是一个整数指针p。函数体里面， *p就表示指针p所指向的那个值。对于 *p赋值，就表示改变指针所指向的那个地址里面的值。

**&运算符**

&运算符用来**取出一个变量所在的内存地址**。

&运算符与*运算符互为逆运算，下面表达式成立。

```
int i = 5;
if (i == *(&i)) // 正确
```

**指针变量的初始化**

声明指针变量之后，编译器会为指针变量本身分配一个内存空间，但是这个内存空间里面的值是随机的，也就是说，指针变量指向的值是随机的。这是一定不能去读写指针变量指向的地址，因为那个地址是随机地址，很可能导致严重后果。

```
int* p;
*p = 1; // 错误
```

上面的代码是错误的，因为p指向的哪个地址是随机的，向这个随机地址里面写入1，会导致意想不到的结果。

```
int* p;
int i;
p = &i;
*p = 13;
```

正确做法是，指针变量声明后，必须先让它指向一个分配好的地址，然后再进行读写，这叫做指针变量的初始化。

示例中，p是指针变量，声明这个变量后，p会指向一个随机的内存地址。这时要将它指向一个已经分配好的内存地址，上例就是再声明一个整数i，编译器会为i分配内存地址，然后让p指向i的内存地址(p = &i;)。初始化完成之后，就可以对p的内存地址进行赋值了(*p = 13;)。

为了防止读写初始化的指针变量，可以将未初始化的指针变量设为NULL。

```
int* p = NULL;
```

NULL在C语言中是一个常量，表示地址为0的内存空间，这个地址是无法使用的，读写该地址会报错。

**指针的运算**

指针本质就是一个无符号的整数，代表了内存地址。它可以进行运算，但是规则并不是整数运算的规则。

1. 指针与整数值的加减运算

   指针与整数值的运算，表示指针的移动。

   ```
   short* j;
   j = (short*)0x1234;
   j = j + 1; // 0x1236
   ```

   j是一个指针，指向内存地址0x1234。由于0x1234本身是整数类型(int)，跟j的类型(short*)并不兼容，所以强制使用类型投射，将0x1234转成了short\*。j+1表示指针向内存地址的高位移动一个单位，而一个单位的short类型占据两个字节的宽度，所以相当于向高位移动两个字节。同样，j-1得到的结果就是0x1232。

   指针移动的单位，与指针指向的数据类型有关。数据类型占据多少个字节，每个单位就移动多少个字节。

2. 指针与指针的加法运算

   指针只能与整数值进行加减运算，两个指针进行加法是非法的。

   ```
   unsigned short* j;
   unsigned short* k;
   x = j + k;
   ```

3. 指针与指针的减法

   相同类型的指针允许进行减法运算，返回它们之间的距离，即相隔多少个数据单位。

   高位地址减去低位地址，返回的是正值；低位地址减去高位地址，返回的是负值。

   ```
   short* j1;
   short* j2;
   
   j1 = (short*)0x1234;
   j2 = (short*)0x1236;
   
   ptrdiff_t dist = j2 - j1;
   print("%td\n", dist); // 1
   ```

   j1和j2是两个指向short类型的指针，变量dist是它们之间的距离，类型为ptrdiff_t，值为1，因为相差2个字节正好存放一个short类型的值。

   4. 指针与指针的比较运算

      指针之间的比较运算，比较的是各自的内存地址哪一个更大，返回值是整数1(true)或0(false)

注：函数不要返回内部变量的指针

```
int* f(void){
  int i;
  // ...
  return &i;
}
```

函数返回内部变量i的指针，这种写法是错误的。因为当函数结束运行时，内部变量就消失了，这时指向内部变量i的内存地址就时无效的，再去使用这个地址是非常危险的。

**函数指针**

函数本身就是一段内存里面的代码，C语言允许通过指针获取函数。

```{
void print(int a){
  printf("%d\n",a);
}

void (*print_ptr)(int) = &print;
```

上面示例中，变量print_ptr是一个函数指针，它指向函数print()的地址。函数print()的地址可以使用&print获得。注意，(*print_ptr)一定要写在圆括号里面，否则函数参数(int)的优先级高于\*，整个式子就会变成void\* print_ptr(int)。

有了函数指针，通过它也可以调用函数。

```
(*print_ptr)(10);
// 等同于
print(10)
```

比较特殊的是，C语言还规定，函数名本身就是指向函数代码的指针，通过函数名就能获取函数地址。也就是说，print和&print是一回事。

```
if(pint == &print) // true
```

对于任意函数，下面的调用函数写法都可用。

```
// 写法一
print(10);
// 写法二
(*print)(10); // 取出指针所指向的内存地址里面的值
// 写法三
(&print)(10); // 取出一个变量所在的内存地址

```

这种特性的应用：如果一个函数的参数或返回值，也是一个函数，那么函数原型可以写成这样：

```
int compute(int (*myfunc)(int), int, int);
//函数compute()的第一个参数也是一个函数
```



















































