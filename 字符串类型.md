C语言没有单独的字符串类型，字符串被当作字符数组，即char类型的数组。

编译器会给数组分配一段连续内存，所有字符存储在相邻的内存单元之中。在字符串结尾，C语言会自动添加一个全是二进制0的字节，写作\0字符，表示字符串结束。所以，字符串"hello"实际存储的数组是{’H','e','l','l','o','\0'}。

所有字符串的最后一个字符，都是\0。这样做的好处是，C语言不需要知道字符串的长度，就可以读取内存里面的字符串，只要发现有一个字符是\0，那么就知道字符串结束了。

注意，双引号里面是字符串，单引号里面是字符，两者不能互换。如果把Hello放在单引号里面，编译器会报错。

**字符串变量的声明**

字符串变量可以声明成一个字符数组，也可以生命成一个指针，指向字符数组。

```
// 写法一
char s[14] = "Hello, world!"

// 写法二
char* s = "Hello, world!"
```

上面两种写法都声明了一个字符串变量s。如果采用第一种写法，由于字符数组的长度可以让编译器自动计算，所以声明时可以省略字符数组的长度。

```
char s[] = "Hello, world!"
```

上面实例中，编译器会将数组s的长度指定为14，正好容纳后面的字符串。

字符数组的长度，可以大于字符串的实际长度。字符串组的长度，不能小于字符串的实际长度。

**字符指针和字符数组，这两种声明字符串变量的写法基本是等价的，但是有两个差异。**

第一个差异是，指针指向的字符串，在C语言内部被当作常量，不能修改字符串本身。

```
char* s = "Hello, world!";
s[0] = 'z'; // 错误
```

上面代码使用指针，声明了一个字符串变量，然后修改了字符串的第一个字符。这种写法是错误的，会导致难以预测的后果，执行时很可能会报错。

如果使用数组声明字符串变量，就没有这个问题，可以修改数组的任意成员。

```
char s[] = "Hello, world!"
s[0] = 'z'
```

原因在于系统会将字符串的字面量保存在内存的常量区，这个区是不允许用户修改的。声明为指针时，指针变量存储的值是一个指向常量区的内存地址，因此用户不能通过这个地址去修改常量区。但是，声明为数组时，编译器会给数组单独分配一段内存，字符串字面量会被编译器解释成字符串数组，逐个字符写入这段新分配的内存之中，而这段新内存是允许修改的。

为了提醒用户，字符串声明为指针后不得修改，可以在声明时使用const说明符，保证该字符是只读的。

```
const char* s = "Hello, world!"
```

第二个差异是，指针变量可以指向其他其他字符串，但是字符数组变量不能指向另一个字符串。

```
char* s = "hello";
s = "world"

char s[] = "hello";
s = "world"; // 报错
```

上面示例中，字符数组的数组名，总是指向初始化时的字符串地址，不能修改。同样，声明字符数组后，不能直接用字符穿赋值。

```
char s[10];
s = "abc" //错误
```

上面示例中，不能直接把字符串赋值给字符数组变量，会报错。原因是字符数组的变量名，跟所指向的数组是绑定的，不能指向另一个地址。

为什么数组变量不能赋值为另一个数组？原因是数组变量所在的地址无法改变，或者说，编译器一旦为数组变量分配地址后，这个地址就绑定这个数组变量了，这种绑定关系是不变的。C语言也因此规定，数组变量是一个不可修改的左值，即不能用赋值运算符为它重新赋值。

想要重新赋值，必须使用C语言原生提供的strcpy()函数，通过字符串拷贝完成赋值。这样做以后，数组变量的地址还是不变的，即strcpy()只是子原地址写入新的字符串，而不是让数组变量指向第的地址。

```
char s[10];
strcpy(s, "abc")
```

strcpy()函数把字符串abc拷贝给变量s。

**字符串常用函数**

- char* strcpy(char dest[], const char source[]): 用于将一个字符串的内容复制到另一个字符串，相当于字符串赋值。该函数的原型定义在string.h头文件里面。

  strcpy()接受两个参数，第一个参数是目的字符串数组，第二个参数是源字符串数组。复制字符串之前，必须要保证第一个参数的长度不小于第二个参数，否则虽然不会报错，但会溢出第一个字符串变量的边界，发生意外。第二个参数的const说明符，表示这个函数不会修改第二个参数。

  strcpy()的返回值是一个字符串指针(即char*)，指向第一个参数。

  ```
  //用途1: 从s2的第7个位置开始拷贝字符串beast，前面的位置不变。这导致s2后面的内容都被截去了，因为会连beast结尾的空字符一起拷贝。strcpy()返回的是一个指针，指向拷贝开始的位置。
  char* s1 = "beast";
  char s2[40] = "Be the best that you can be.";
  char* ps;
  
  ps = strcpy(s2 + 7, s1);
  
  puts(s2); // Be the beast
  puts(ps); // beast
  
  // 用途2：连续为多个字符数组赋值
  strcpy(str1, strcpy(str2, "abcd"))
  ```

  strcpy()函数功能自实现

  ```
  char* strcpy(char* dest, const char* source){
    char* ptr = dest;
    while (*dest++ = *source++);
    return ptr;
  }
  
  int main(void){
    char str[25];
    strcpy(str, "hello world");
    printf("%s\n", str);
    return 0;
  }
  ```

  while(*dest++ = *source++)这个循环，依次将source的每一个字符赋值给dest，然后向下一个位置，直到遇到\0，循环判断条件不再为真，从而跳出循环。其中，\*dest++这个表达式等同于\*(dest++)，即先返回dest这个地址，再进行自增运算移向下一个位置，而\*dest可以对当前位置赋值。

  strcpy()函数有安全风险，因为它并不检查目标字符串的长度，是否足够容纳源字符串的副本，可能导致写入溢出。

- char* strncpy(char* dest, char* src, size_t n)：strncpy()跟strcpy()用法完全一样，只是多了第3个参数，用来指定复制的最大字符数，防止溢出目标字符串变量的边界；

  第三个参数n定义了复制的最大字符数。如果达到最大字符数以后，源字符串仍然没有复制完，就会停止复制，这时目的字符串结尾将没有终止符\0。如果源字符串的字符数小于n，则strncpy()的行为与strcpy()完全一致。

  ```
  strncpy(str1, str2, sizeof(str1) - 1);
  str1[sizeof(str1) - 1] = '\0'
  ```

- char* strcat(char* s1, const char* s2)：用于连接字符串，它接受两个字符串作为参数，把第二个字符串的副本添加到第一个字符串的末尾。这个函数会改变第一个字符串，但是第二个字符串不变。

  注意，strcat()的第一个参数的长度，必须足以容纳添加第二个参数字符串。否则，拼接后的字符串会溢出第一个字符串的边界，写入相邻的内存单元，建议使用下面的strncat()替代。

- char* strncat(const char* dest, const char* src, size_t n)：用于连接两个字符串，用法与strcat()完全一致，只是增加了第三个参数，指定最大添加的字符数。在添加过程中，一旦达到指定的字符数，或者在源字符串遇到空字符\0，就不再添加了。返回第一个参数，即目标字符串指针。

  通常写成这样：

  ```
  strncat(str1, str2, sizeof(str1) - strlen(str1) - 1)
  ```

  strncat()总是会在拼接结果的结尾，自动添加空字符\0，所以第三个参数的最大值，应该是str1的变量长度减去str1的字符串长度，再减去1。

- int strcmp(const char* s1, const char* s2)：比较两个字符串内容。按照字典顺序，如果两个字符串相同，返回值为0；如果s1小于s2，strcmp()返回值小于0；如果s1大于s2，返回值大于0。

  strcmp()只用来比较字符串，不用来比较字符。因为字符就是小整数，直接用相等运算符(==)就能比较。所以不要把字符串类型(char)的值，放入strcmp()当作参数。

- int strncmp(const char* s1, const char* s2, size_t n)：字符串比较，只比较到指定的位置。增加了第三个参数，指定了比较的字符数。返回值与strcmp()一样。

- int sprintf(char* s, const char* format, ...)：跟和拿书printf()类似，但是用于将数据写入字符串，而不是输出到显示器。第一个参数是字符串指针变量，其余参数和printf()相同，即第二个参数是格式字符串，后面的参数是待写入的变量列表。

  ```
  char first[6] = "hello";
  char last[6] = "world";
  char s[40];
  
  sprintf(s, "%s %s", first, last)
  printf("%s\n", s) // hello world
  ```

  sprintf()的返回值是写入变量的字符数量(不计入尾部的空字符\0)，如果遇到错误，返回负值。

  sprintf()有严重的安全风险，如果写入的字符串过长，超过了目标字符串的长度，sprintf()依然会将其写入，导致发生溢出。为了控制写入的字符串的长度，提供了另一个函数snprintf()。

- int snprintf(char* s, size_t n, const char* format, ...)：参数n用来控制写入变量的字符串不超过n-1个字符，剩下一个位置写入空字符\0。

  snprintf()总是会自动写入字符串结尾的空字符。如果你尝试写入的字符数超过指定的最大字符数，snprintf()会写入n-1个字符，留出最后一个位置写入空字符。

  snprintf()的返回值是写入格式字符串的字符数量(不计入尾部的空字符\0)。如果n足够大，返回值应该小于n，但是有时候字符串的长度可能大于n，那么这时返回值会大于n，但实际上真正写入变量的还是n-1个字符。如果遇到错误，返回一个负值。因此，返回值只有在非负并且小于n时，才能确认完整的格式字符串写入了变量。





























